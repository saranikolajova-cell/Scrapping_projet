"""
PROJET : ESTIMATEUR DE COÛT DE REPAS AUTOMATISÉ (Web Scraping & Data Analysis)
DATE : Février 2026
DESCRIPTION : 
Ce script croise deux sources de données web pour estimer le coût d'une recette de cuisine :
1. Marmiton.org : Pour l'extraction des ingrédients d'une recette spécifique.
2. Numbeo.com : Pour récupérer le coût de la vie (prix des denrées) dans une ville donnée.

TECHNOLOGIES : Python, Selenium, Polars.
"""

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import polars as pl
import time

# ==============================================================================
# 1. BASE DE CONNAISSANCES (MAPPING SÉMANTIQUE)
# ==============================================================================
# Ce dictionnaire sert de "cerveau" au programme. Il permet d'associer un ingrédient
# brut trouvé sur une recette (ex: "lardon fumé") à une catégorie générique (ex: "VIANDE_ROUGE").
# Cela permet d'appliquer une logique de tarification standardisée.

CATEGORIES = {
    "VIANDE_ROUGE": ["boeuf", "bœuf", "steak", "porc", "lard", "jambon", "saucisse", "veau", "agneau", "chorizo", "merguez", "viande", "bacon"],
    "VOLAILLE": ["poulet", "dinde", "canard", "oie", "volaille", "chapon", "cuisse"],
    "POISSON": ["poisson", "saumon", "thon", "crevette", "moule", "cabillaud", "fruit de mer", "calamar"],
    "LEGUME": ["tomate", "oignon", "carotte", "courgette", "aubergine", "poivron", "ail", "échalote", "echalote", "champignon", "salade", "épinard", "haricot", "pois", "pomme de terre", "patate", "chou", "poireau", "avocat", "concombre"],
    "FRUIT": ["pomme", "poire", "banane", "citron", "orange", "fraise", "framboise", "ananas", "fruit"],
    "FECULENT": ["riz", "pâte", "spaghetti", "nouille", "blé", "semoule", "quinoa", "pain", "baguette", "toast"],
    "LAITIER": ["lait", "crème", "beurre", "yaourt", "fromage", "gruyère", "parmesan", "mozzarella", "comté"],
    "EPICERIE_SUCREE": ["sucre", "miel", "sirop", "chocolat", "cacao", "confiture", "farine", "maïzena", "levure", "vanille"],
    "CONDIMENT": ["sel", "poivre", "huile", "vinaigre", "sauce", "soja", "moutarde", "ketchup", "mayonnaise", "cube", "bouillon", "vin", "alcool", "rhum", "eau"],
    "AROMATE": ["gingembre", "persil", "basilic", "thym", "laurier", "coriandre", "menthe", "épice", "curry", "paprika", "cumin", "cannelle", "herbe", "piment", "quatre-épices"]
}

# ==============================================================================
# 2. FONCTIONS DE SCRAPING (EXTRACTION DE DONNÉES)
# ==============================================================================

def get_numbeo_prices(driver, city):
    """
    Navigue sur Numbeo pour récupérer les indices de prix locaux.
    
    Args:
        driver (WebDriver): L'instance du navigateur Selenium.
        city (str): Le nom de la ville cible (ex: 'Paris').
        
    Returns:
        dict: Un dictionnaire contenant les prix de référence par catégorie (€/kg).
    """
    print(f"[INFO] Connexion à Numbeo pour la ville : {city}...")
    
    # Construction de l'URL avec forçage de la devise en EUR
    driver.get(f"https://www.numbeo.com/cost-of-living/in/{city}?displayCurrency=EUR")
    
    # Initialisation des prix par défaut (Valeurs refuges si le scraping échoue)
    prix_ref = {
        "base_viande": 15.0,  
        "base_volaille": 10.0,
        "base_legume": 2.50,
        "base_feculent": 2.00,
        "base_laitier": 10.0,
        "base_fruit": 2.50
    }
    
    try:
        # Attente explicite : on attend que le tableau de données soit chargé dans le DOM
        WebDriverWait(driver, 5).until(EC.presence_of_element_located((By.CLASS_NAME, "data_wide_table")))
        rows = driver.find_elements(By.TAG_NAME, "tr")

        # Analyse ligne par ligne du tableau Numbeo
        for row in rows:
            text = row.text
            try:
                # Extraction et nettoyage du prix (retrait du symbole € et conversion en float)
                element_prix = row.find_element(By.CLASS_NAME, "priceValue")
                valeur = float(element_prix.text.replace("€", "").replace(",", ""))
                
                # Mise à jour dynamique des références si les mots-clés sont trouvés
                if "Chicken" in text: prix_ref["base_volaille"] = valeur
                elif "Beef" in text: prix_ref["base_viande"] = valeur
                elif "Rice" in text: prix_ref["base_feculent"] = valeur
                elif "Cheese" in text: prix_ref["base_laitier"] = valeur
                elif "Apple" in text or "Orange" in text: prix_ref["base_fruit"] = valeur
                elif "Tomato" in text or "Potato" in text or "Onion" in text: 
                    # Moyenne lissée pour la catégorie légumes
                    prix_ref["base_legume"] = (prix_ref["base_legume"] + valeur) / 2
            except:
                continue
                
        print("[SUCCES] Indices de prix locaux mis à jour.")
    except Exception as e:
        print(f"[AVERTISSEMENT] Échec partiel du scraping Numbeo ({e}). Utilisation des valeurs par défaut.")

    return prix_ref

def get_marmiton_recipe(driver, url):
    """
    Navigue sur Marmiton pour extraire la liste des ingrédients.
    
    Args:
        driver (WebDriver): L'instance du navigateur.
        url (str): L'URL complète de la recette.
        
    Returns:
        list: Une liste de dictionnaires [{'Nom': '...', 'Qte': '...'}, ...]
    """
    print("[INFO] Analyse de la recette Marmiton...")
    driver.get(url)
    time.sleep(2) # Pause pour laisser les scripts JS s'exécuter

    # Gestion de la bannière de consentement Cookies (si présente)
    try: 
        driver.find_element(By.ID, "didomi-notice-agree-button").click()
    except: 
        pass

    ingredients = []
    try:
        # Scroll vers le bas pour déclencher le chargement dynamique (Lazy Loading)
        driver.execute_script("window.scrollTo(0, 600);")
        
        # Sélecteurs CSS spécifiques à la structure actuelle de Marmiton
        items = driver.find_elements(By.CLASS_NAME, "card-ingredient-title")
        quantities = driver.find_elements(By.CLASS_NAME, "card-ingredient-quantity")
        
        for i in range(len(items)):
            nom = items[i].text.strip()
            # Gestion des cas où la quantité est absente
            qte = quantities[i].text.strip() if i < len(quantities) else ""
            if qte == "": qte = "1"
            
            ingredients.append({"Nom": nom, "Qte": qte})
    except Exception as e:
        print(f"[ERREUR] Impossible de lire les ingrédients : {e}")
        
    return ingredients

def identifier_famille(nom_ingredient):
    """
    Algorithme de classification par mots-clés.
    Compare le nom de l'ingrédient aux listes définies dans CATEGORIES.
    """
    nom_min = nom_ingredient.lower()
    
    for famille, mots_cles in CATEGORIES.items():
        for mot in mots_cles:
            if mot in nom_min:
                return famille
    return "AUTRE" # Catégorie par défaut si aucun mot-clé n'est trouvé

# ==============================================================================
# 3. PROGRAMME PRINCIPAL (FLUX D'EXÉCUTION)
# ==============================================================================

if __name__ == "__main__":
    print("--- DÉMARRAGE DE L'ESTIMATEUR DE COÛT ---")
    
    # Entrées utilisateur
    ville = input("Veuillez entrer la ville cible (ex: Paris) : ")
    url = input("Veuillez entrer l'URL de la recette Marmiton : ")

    # Configuration du WebDriver Chrome
    # L'option log-level=3 supprime les messages techniques non critiques de la console
    options = webdriver.ChromeOptions()
    options.add_argument("--log-level=3") 
    
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)

    data_finale = []
    cout_total = 0.0

    try:
        # Étape 1 : Récupération des données économiques (Numbeo)
        prix_marche = get_numbeo_prices(driver, ville)
        
        # Étape 2 : Extraction technique de la recette (Marmiton)
        recette = get_marmiton_recipe(driver, url)
        
        print("\n[ACTION] Calcul du coût estimatif en cours...")

        # Étape 3 : Traitement et Calcul des coûts
        for ing in recette:
            nom = ing["Nom"]
            famille = identifier_famille(nom)
            
            prix_estime = 0.0
            explication = ""

            # Logique métier : Application des règles de calcul selon la famille
            # Les quantités sont estimées (ex: 150g pour une portion de viande)
            if famille == "VIANDE_ROUGE":
                prix_estime = prix_marche["base_viande"] * 0.150
                explication = "Viande (Index: Boeuf)"
                
            elif famille == "VOLAILLE":
                prix_estime = prix_marche["base_volaille"] * 0.150
                explication = "Volaille (Index: Poulet)"
                
            elif famille == "POISSON":
                # Le poisson est estimé 20% plus cher que la viande rouge moyenne
                prix_estime = prix_marche["base_viande"] * 1.2 * 0.150 
                explication = "Poisson (Index estimé)"
                
            elif famille == "LEGUME":
                prix_estime = prix_marche["base_legume"] * 0.150 
                explication = "Légume (Moyenne locale)"
                
            elif famille == "FRUIT":
                prix_estime = prix_marche["base_fruit"] * 0.100
                explication = "Fruit"
                
            elif famille == "FECULENT":
                prix_estime = prix_marche["base_feculent"] * 0.100 
                explication = "Féculent (Index: Riz)"
                
            elif famille == "LAITIER":
                prix_estime = prix_marche["base_laitier"] * 0.050 
                explication = "Produit Laitier"
                
            elif famille == "EPICERIE_SUCREE":
                prix_estime = 0.20 # Forfaitaire
                explication = "Épicerie sèche"
                
            elif famille == "CONDIMENT":
                prix_estime = 0.10 # Forfaitaire
                explication = "Condiment"
                
            elif famille == "AROMATE":
                prix_estime = 0.30 
                explication = "Aromate/Herbe fraîche"
                
            else:
                prix_estime = 0.50 # Valeur tampon pour les ingrédients inconnus
                explication = "Non identifié (Forfait)"

            # Agrégation des résultats
            cout_total += prix_estime
            
            data_finale.append({
                "Ingrédient": nom,
                "Catégorie": famille,
                "Base de Calcul": explication,
                "Coût Est. (€)": round(prix_estime, 2)
            })

    finally:
        # Fermeture propre du navigateur pour libérer la mémoire
        driver.quit()
        print("[INFO] Fermeture du navigateur.")

    # ==============================================================================
    # 4. PRÉSENTATION DES RÉSULTATS
    # ==============================================================================
    print(f"\n--- RAPPORT FINANCIER : {ville.upper()} ---")
    
    # Utilisation de Polars pour un affichage tabulaire performant
    df = pl.DataFrame(data_finale)
    print(df)
    
    print("="*50)
    print(f"COÛT TOTAL ESTIMÉ DU REPAS : {cout_total:.2f} €")
    print("="*50)
